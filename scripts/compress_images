#!/bin/bash
set -e

if ! test -d "$1"; then
  echo "Expecting a directory as input"
  exit
fi

function relpath() {
  python -c "import os,sys;print(os.path.relpath(*(sys.argv[1:])))" "$@";
}

function absolute() {
  echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")"
}

function compress_file_destructive() {
  local FULLPATH=$(realpath "$1")
  local FILETYPE=$(file "$FULLPATH")

  case $FILETYPE in
      *"image data"*)
  	magick "$FULLPATH" -strip -interlace Plane -quality 50% -quiet -resize x2160 "$FULLPATH"
  	;;
      *"Zip archive data"*)
	compress_cbz_destructive "$1"
	;;
      *)
  	;;
  esac
}

function compress_file_to_output_dir() {
  local TEMP=$(mktemp -d -p /tmp)
  local FULLPATH=$(realpath "$1")
  local OUTDIR=$(absolute "$2")
  local FILENAME=$(basename "$FULLPATH")
  echo Compressing \'"$FILENAME"\' through $TEMP...
  mkdir -p $TEMP
  cp "$FULLPATH" $TEMP/"$FILENAME"
  compress_file_destructive $TEMP/"$FILENAME"
  mkdir -p "$OUTDIR"
  cp $TEMP/"$FILENAME" "$OUTDIR/"
  rm -rf $TEMP
}

function compress_cbz_destructive() {
  local FULLPATH=$(realpath "$1")
  local DIR=$(dirname -- "$FULLPATH")
  local FILENAME=$(basename "$1")
  cd $DIR
  unzip -q -j "$FILENAME"
  rm "$FILENAME"
  find $DIR -type f -print0 | while IFS= read -r -d '' file; do
    compress_file_destructive "$file"
  done
  zip -0 -q "$FILENAME" *
  find . -type f \! \( -name "$FILENAME" \) -exec rm {} \;
  cd -
}

function compress_folder_contents() {
  local DIRPATH=$(realpath "$1")
  find $DIRPATH -type f -not -path '*/.*' -print0 | while IFS= read -r -d '' file; do
    local OUTPUTPATH="$PWD"/compressed
    local FULLPATH=$(realpath "$file")
    RELATIVE_FILE=$(relpath "$FULLPATH" "$DIRPATH")
    echo "$OUTPUTPATH"/"$RELATIVE_FILE"
  done
}

compress_folder_contents $1

exit


compress_file_to_output_dir "$1" ./completed

exit
